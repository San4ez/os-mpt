<!DOCTYPE html>
<html>
<head>
	<title>Практическая работа #9</title>
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="720">
	<link rel="stylesheet" href="css/style.css">
    <link href="http://fonts.googleapis.com/css?family=Raleway:700,300" rel="stylesheet"
          type="text/css">
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/prettify.css">
</head>
<body>


<div class="wrapper">
    <nav>
        <div class="pull-left">
            <h1><a href="/os-mpt"><span>Все материалы</span></a></h1>
        </div>
        <div class="pull-right">
        </div>
    </nav>
    <header>
        <div class="container">
            <h2 class="lone-header">Лабораторная #9 по ОС</h2>
        </div>
    </header>
    <section>
        <div class="container">
            <ul class="docs-nav">
                <li><a href="#init" class="cc-active">Введение</a></li>
				<li><a href="#comm" class="cc-active">Используемые команды/утилиты</a></li>
				<li><a href="#exe" class="cc-active">Выполнение</a></li>
                <li><a href="#qwe" class="cc-active">Контрольные вопросы</a></li>
                <li><a href="#source" class="cc-active">Ссылки</a></li>
            </ul>
			
            <div class="docs-content">
            <h2>Лабораторная работа №9 - «Администрирование системы, работа с дисками»</h2>

			<b>Цель работы:</b> Получить представление о работе c устройствами и планировщике заданий в Unix системах.

             <h3 id="init">Введение</h3>
             <p><b>Специальный файл устройства</b>, или просто файл устройства (англ. special device file) — это один из типов файлов в UNIX-подобной операционной системе. Специальные файлы устройств содержат данные, необходимые операционной системе для взаимодействия с физическими устройствами, такими как диски и дисководы, принтеры и факсы и т. п. Фактически, специальные файлы устройств являются <b>указателями на драйверы устройств, и когда процесс обращается к файлу устройств, он по сути работает с драйвером этого устройства</b>. </p>

             <p>Поскольку в операционной системе есть разные типы устройств, то и файлы устройств бывают разными. Есть два типа файлов устройств: <b>блочные </b>(англ. block special files) и <b>символьные</b> (англ. character special files). Блочные файлы устройств используются для передачи данных, разделённых на пакеты фиксированной длины — блоки. А символьные файлы устройств используются для небуферизованного обмена данными. Большинство устройств способно принимать и отправлять данные либо блоками (блочные устройства), либо сплошным потоком байтов (символьные устройства), но некоторые (такие как жёсткий диск) сочетают в себе обе эти возможности. Работа с первым типом устройств возможна либо через блочные, либо через символьные файлы, а вот с последним типом — подходят и те, и другие.</p>

             <p>Файлы устройств размещаются в каталоге <b>/dev</b> или в его подкаталогах.</p>
             <p>Узнать информацию о файле устройства можно с помощью команд <b>file</b> и <b>ls</b>.</p>
             <p><b>Примеры подобных файлов:</b>
             <ol>
                 <li>/dev/sd буква — жёсткий диск (в системах на ядре Linux)</li>
                 <li>/dev/sd буква номер — раздел диска (в системах на ядре Linux)</li>
                 <li>/dev/sr номер (/dev/scd номер) — CD-ROM</li>
                 <li>/dev/eth номер — сетевые интерфейсы Ethernet</li>
                 <li>/dev/wlan номер — сетевые интерфейсы Wireless</li>
                 <li>/dev/lp номер — принтеры</li>
                 <li>/dev/video номер — устройства изображений, камеры, фотоаппараты и т. д.</li>
                 <li>/dev/bus/usb/000/номер — устройство номер на шине USB первого контроллера (000) (в системах на ядре Linux)</li>
                 <li>/dev/tty номер — текстовый терминал</li>
                 <li>/dev/random — случайные данные (псевдоустройство)</li>
                 <li>/dev/null — пусто (псевдоустройство)</li>
                 <li>/dev/zero — нулевые байты (псевдоустройство)</li>
                 <li>Кроме того, каталог /dev содержит loopback-устройства ("петлевые" устройства), например /dev/loop0. С помощью такого устройства можно представить обычный файл как блочное устройство ввода/вывода. Это позволяет монтировать целые файловые системы, находящиеся в отдельных больших файлах.</li>
                 <li></li>
             </ol>
             </p>


          	 <h3 id="comm">Используемые команды/утилиты</h3>
             <p>Используемые команды в текущей лабораторной работе:
             <ol>
                 <li>dd (dataset definition) — программа UNIX, предназначенная как для копирования, так и для конвертации файлов.</li>
                 <li>fdisk - утилита для управления раздлелами жесткого диска</li>
                 <li>crontab - местный планировщик заданий</li>
             </ol>
             </p>

             <h3 id="exe">Выполнение</h3>
            <p><b>Сначала поработаем с dd</b>. Команда (а по факту это все таки утилита) <b>dd</b> позволяет копировать что-то побайтово. Для чего это может пригодиться, например: выполнять резервную копию MBR, создавать дампы данных с различных накопителей, зеркалировать носители информации, восстанавливать из резервной копии данные на носители, скопировать первые n байт файла, пропустить m байт от начала, прочитать файл с дефектного носителя, транслировать содержимое файла в ASCII, и многое другое, а, при совмещении возможностей dd и поддержке криптографических алгоритмов ядра Linux, можно даже создавать зашифрованные файлы, содержащие в себе целую файловую систему. </p>
            <p>Пример комманды: 
                <p>
<pre class="prettyprint">
$ dd if=/dev/urandom of=/dev/null bs=100M count=5
</pre>       
                </p>
            Параметры:
            <ol>
                <li><b>if:</b> указывает на источник, т.е. на то, откуда копируем. Указывается файл, который может быть как обычным файлом, так и файлом устройства.</li>
                <li><b>of:</b> указывает на файл назначения. То же самое, писать можем как в обычный файл, так и напрямую в устройство.</li>
                <li><b>bs:</b> количество байт, которые будут записаны за раз. Можно представлять этот аргумент как размер куска данные, которые будут записаны или прочитаны, а количество кусков регулируется уже следующим параметром.</li>
                <li><b>count:</b> как раз то число, которое указывает: сколько кусочков будет скопировано.</li>
            </ol>
            </p>
            <p>Таким образом, описанная команда читает 5*100 мегабайт из устройства /dev/urandom в устройство /dev/null. Придавая этой команде смысловую нагрузку получается, что система сгенерирует 500 мегабайт случайных значений и запишет их в null устройство т.е. в никуда. Конечно, единственное, что сделает эта команда: нагрузит процессор на несколько секунд. </p>
        	
            <p>Создадим резервную компию MBR, для этого нам потребуется скопировать первые 512 байтов информации с диска, именно в них содержиться MBR. MBR состоит из небольшой части ассемблерного кода (начальный загрузчик – 446 байт), таблицы разделов - 4 первичных раздела (16 байт каждый) и стража (0xAA55). Вообще в целом MBR <a href="http://wiki.osdev.org/MBR_(x86)"> выглядит вот так.</a>(там внизу статьи будет ассемблерное представление MBR) </p>
            <p>Команда для создания резервной копии выглядит вот так:</p>
<pre class="prettyprint">
$ dd dd if=/dev/sda of=/path/mbr-backup bs=512 count=1
</pre>  
            <p>И вот такой командой восстановить если друг у вас все посыпалось:</p>
<pre class="prettyprint">
$ dd if=/path/mbr-backup of=/dev/sda bs=512 count=1
</pre> 
        <p>Подобный бекап выглядит вот так.</p>
         <img src="image/lab9/image000.jpg">

        <p>На самом деле данная команда очень функциональна, с её использованием вы можете ознакомиться по этой <a href="https://habrahabr.ru/post/117050/"> ссылке. </a> </p>


        <p><b>Теперь поработаем с fdisk</b>. Если что это местный аналог Diskpart, который есть в Windows. Для выполнения этой части лабораторной вам потребуется бесхозная флешка. С помощью этой утилиты мы разобьем вашу флешку на разделы, которые будут для условной unix системы. <b>АХТУНГ!! Если будете брать флешку на которой есть важный документы, то перед началом лабораторной работы перенесите их с неё. </b> </p>

        <p>Чтобы подключить флешку к виртуальной машине требуется подключить флешку к ПК и дождаться пока её опознают, и дальше в интерфейсе виртуальной машины выбрать следующий пункт меню, где найти нужную вам флешку: </p>
         <img src="image/lab9/image001.gif">
         <p>Она подключиться и появится на панели слева:</p>
         <img src="image/lab9/image002.gif">
         <p>Для начала просто посмотрим список имеющихся дисков и информацию о них, выполняйте данную команду от имени администратора </p>
<pre class="prettyprint">
$ ls /dev | grep sd
</pre> 

        <p>Имена разделов диска получаются добавлением к имени диска десятичного числа: sda1 и sda2 представляют первый и второй разделы на первом диске SCSI в системе. 
        <p> Вот реальный пример. Предположим, что вы имеете систему с 2-мя SCSI дисками, один имеет SCSI адрес 2, а другой SCSI адрес 4. Первый диск (с адресом 2) называется sda, а второй sdb. Если диск sda содержит 3 раздела, то их имена будут sda1, sda2 и sda3. То же относится к диску sdb и его разделам. </p>
        <p>В общем итоге у нас есть один диск системный, с 4-мя разделами(sda) и флешка(sdb) </p>
        <img src="image/lab9/image003.gif">
        <p>Так же, помимо sda могут быть и другие: sdb, sdc и.т.д.</p>
        <p>Если у нас есть созданные разделы, информацию о них можем посмотреть такой командой:</p>
<pre class="prettyprint">
$ /sbin/fdisk -l /dev/sdb
</pre> 
        <p>Вот, мы нашли тот раздел, над которым будем издеваться. </p>
        <img src="image/lab9/image004.gif">


        <p>Далее, мы можем переходить к работе с fdisk, для этого вводим команду и в аргументе указываем нужный нам диск, в данном случае «/dev/sdb».</p>

<pre class="prettyprint">
$ fdisk /dev/sdb
</pre> 
        <p>После чего, попадаем в меню fdisk. Сказано набирать m для справки, смело набираем  Читаем и изучаем функционал. </p>
        <img src="image/lab9/image005.gif">

        <p>Предположим, команда «/sbin/fdisk -l /dev/sda» показала, что диск «sdb» пустой и нам нужно разбить его.</p>

        <p>Для начала создадим раздел для «boot». Также следует упомянуть, что очередность имеет значение, чем ближе раздел к началу диска — тем больше скорость считывания, из-за скорости вращения. Сначала командой d – удалим разделы, которые уже есть Потом командой  p – создадим новые разделы </p>
        <img src="image/lab9/image006.gif">

        <p><b>После ввода n fdisk у вас будет спрашивать про параметры разделы, т.к. </b></p>
        <img src="image/lab9/image007.gif">

        <p>Далее, следует создать «swap» (раздел подкачки). Обычно в 2 раза больше ОЗУ</p>
        <img src="image/lab9/image008.gif">

        <p>После чего, создаем корень «/usr».</p>
        <img src="image/lab9/image009.gif">

        <p>Далее, с помощью fdisk, нам нужно создать расширенный раздел «extended». Если вы планируете обойтись четырьмя разделами (например: /boot, swap, /usr, /home), тогда создавайте четвертый «primary».</p>
        <img src="image/lab9/image010.gif">

        <p>Продолжаем дальше создавать логические разделы «logical». Создадим раздел «/tmp».</p> 
        <img src="image/lab9/image011.gif">

        <p><b>Далее мы умышленно пропустим некоторые разделы из стандартной файловой системы UNIX, но вы их можете до создавать сами по точно такой же схеме.</b></p>

        <p>На этом операции с fdisk-ом не закончены. Нам нужно установить флаг загрузочного раздела.</p>
        <img src="image/lab9/image012.gif">

        <p>Далее, нам нужно изменить метку типа раздела, для «swap». Во время выбора, fdisk нам предложит напомнить типы известных разделов, для этого после вывода <Hex code (type L list codes): > введите большую «L» и найдите цифру нужного раздела.</p>
        <img src="image/lab9/image013.gif">

        <p>Потом, выводим наши созданные разделы на экран, убеждаемся, что все в порядке.</p>
        <img src="image/lab9/image014.gif">

        <p>Сохраняемся (команда W), на этом все, с fdisk закончили.</p>
        <img src="image/lab9/image015.gif">

        <p>Вот и все, теперь вы немного умеете работат с дисками под Unix. Теперь ваша задача зайти в Windows и удалить все разделы и вернуть флешку в первоначальное состояние.</p>


        <p>Так то в принципе все получилось, те разделы которые мы создавали они создались. Если у вас появилась ошибка(особенно на последнем этапе, на котором мы сохраняем изменения), то сделайте скриншот и покажите преподавателю! Помимо вышеописанного средства есть и другие, графические средства для работы с жесткими дисками, например GParted. </p>
        <img src="image/lab9/image016.gif">
        <p>В Windows восстановление единого раздела происходит через контекстное меню, щелкаете по конкретному разделу и выбираете "удалить", и место на устройстве станет нераспределенным и проделываете это со всеми разделами, потом выбираете нераспределенную область и делаете единый раздел.</p>


        <p><b>Ну и напоследок для кучи поработает с crontab</b> - местным планировщиком заданий. </p>
        <p>Создайте в домашней директории пустой файл, с таким же расширением. Первая команда создаёт файл. Вторая команда дает ему права на выполнения.</p>
        <img src="image/lab9/image017.gif">

        <p>И просто в файле перечислите команды какие-либо, из 8 лабораторной работы по Unix.</p>
        <img src="image/lab9/image018.gif">
        <p>Теперь открывает crontab, командой <b>crontab –e</b>, после этой команды он у вас спросит, какой текстовый редактор использовать, выберите из предложенных - nano. И перед вами откроется текстовый файл в консоли, навигация по нему стрелочками. Допишите в него последнюю строчку, там где «alex» - имя ВАШЕГО пользователя и сохранитесь комбинацией клавиш ctrl + o и выйдите ctrl + x. И теперь у вас каждую минуту в вашей домашней директории будет создаваться куча папок и файл. Чтобы отключить просто уберите эту строчку из файла. </p>
        <img src="image/lab9/image019.gif">
        <p>И теперь этот скрипт будет выполняться у вас каждое n-ое количество времени. По поводу указания времени у каждой команды в планировщике.</p>
        <img src="image/lab9/image020.png">




			<h3 id="qwe">Контрольные вопросы</h3>
			<ol>
			<li>Что такое MBR.</li>
            <li>Что такое утилита DD и какую работы мы с помощью неё может выполнить?</li>
            <li>Что такое fdisk и какую работы с помощью неё мы можем выполнить?</li>
            <li>Что такое crontab и для чего он может нам пригодиться? </li>
			</ol>

			<h3 id="source">Ссылки</h3>
			<ol>
				<li><a href="http://help.ubuntu.ru/manual/терминал"> Гайд по терминалу в Ubuntu </a></li>
				<li><a href="http://alvinalexander.com/unix/edu/examples/"> Команды Unix, английский язык </a></li>
				<li><a href="http://forum.ubuntu.ru/index.php?topic=14535.15"> Шпаргалка по командам </a></li>
                <li><a href="https://ru.wikipedia.org/wiki/Cron"> Crontab </a></li>
                <li><a href="http://www.oldnix.org/fdisk-linux/"> Работа с Fdisk </a></li>


			</ol>
			
            </div>
        </div>
    </section>
</div>
<script src="js/jquery.min.js"></script>
<script type="text/javascript" src="js/prettify/prettify.js"></script>
<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?lang=css&skin=sunburst"></script>
<script src="js/layout.js"></script>
</body>
</html>

